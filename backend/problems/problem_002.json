{
  "id": "002",
  "title": "LRU Cache",
  "difficulty": "medium",
  "description": "Implement a Least Recently Used (LRU) cache class named `LRUCache`. The class must support two operations in O(1) average time:\n\n- `LRUCache(capacity)`: Constructor. Initialise the cache with a positive capacity.\n- `get(key)`: Return the value if the key exists, else return -1. Accessing a key marks it as recently used.\n- `put(key, value)`: Insert or update the key. If inserting a new key causes the cache to exceed capacity, evict the least recently used key first.\n\nTest driver calls operations as a sequence and returns a list of results (None for put operations).",
  "functionSignature": "class LRUCache:\n    def __init__(self, capacity: int): ...\n    def get(self, key: int) -> int: ...\n    def put(self, key: int, value: int) -> None: ...",
  "constraints": [
    "1 <= capacity <= 3000",
    "0 <= key <= 10^4",
    "0 <= value <= 10^5",
    "get and put must each run in O(1) average time"
  ],
  "examples": [
    {
      "input": "cache = LRUCache(2); cache.put(1,1); cache.put(2,2); cache.get(1); cache.put(3,3); cache.get(2)",
      "output": "[None, None, 1, None, -1]",
      "explanation": "After put(3,3), key 2 is evicted (LRU). get(2) returns -1."
    }
  ],
  "testCases": [
    {
      "label": "Basic LRU eviction",
      "args": "( lambda: ( c := __import__('types').SimpleNamespace(), setattr(c, 'r', []), [c.r.append(LRUCache(2).put(1,1) or LRUCache(2).put(2,2) or LRUCache(2).get(1))], c.r )() )[0]",
      "expected": null,
      "ordered": true,
      "weight": 0,
      "note": "See driver below"
    }
  ],
  "testCases": [
    {
      "label": "Standard sequence: put, put, get, put, get evicted key",
      "args": "( lambda ops=[\n  ('put',1,1),('put',2,2),('get',1),('put',3,3),('get',2),('put',4,4),('get',1),('get',3),('get',4)\n]: [\n  r for c in [LRUCache(2)]\n  for op in ops\n  for r in [c.get(op[1]) if op[0]=='get' else (c.put(op[1],op[2]) or None)]\n] )()",
      "expected": [null, null, 1, null, -1, null, -1, 3, 4],
      "ordered": true,
      "weight": 3
    },
    {
      "label": "get on empty cache returns -1",
      "args": "( lambda c=LRUCache(1): c.get(42) )()",
      "expected": -1,
      "ordered": true,
      "weight": 1
    },
    {
      "label": "put overwrites existing key, does not change capacity count",
      "args": "( lambda ops=[('put',1,1),('put',1,100),('get',1)]: [\n  r for c in [LRUCache(1)]\n  for op in ops\n  for r in [c.get(op[1]) if op[0]=='get' else (c.put(op[1],op[2]) or None)]\n] )()",
      "expected": [null, null, 100],
      "ordered": true,
      "weight": 2
    }
  ],
  "hiddenTestCases": [
    {
      "label": "HIDDEN: Capacity 1 — every put evicts previous",
      "args": "( lambda ops=[('put',1,1),('put',2,2),('get',1),('get',2)]: [\n  r for c in [LRUCache(1)]\n  for op in ops\n  for r in [c.get(op[1]) if op[0]=='get' else (c.put(op[1],op[2]) or None)]\n] )()",
      "expected": [null, null, -1, 2],
      "ordered": true,
      "weight": 3
    },
    {
      "label": "HIDDEN: get refreshes recency — protects accessed key from eviction",
      "args": "( lambda ops=[('put',1,1),('put',2,2),('get',1),('put',3,3),('get',1),('get',2)]: [\n  r for c in [LRUCache(2)]\n  for op in ops\n  for r in [c.get(op[1]) if op[0]=='get' else (c.put(op[1],op[2]) or None)]\n] )()",
      "expected": [null, null, 1, null, 1, -1],
      "ordered": true,
      "weight": 4
    },
    {
      "label": "HIDDEN: Updating value of MRU key should not evict it",
      "args": "( lambda ops=[('put',1,1),('put',2,2),('put',1,10),('put',3,3),('get',2),('get',1)]: [\n  r for c in [LRUCache(2)]\n  for op in ops\n  for r in [c.get(op[1]) if op[0]=='get' else (c.put(op[1],op[2]) or None)]\n] )()",
      "expected": [null, null, null, null, -1, 10],
      "ordered": true,
      "weight": 4
    },
    {
      "label": "HIDDEN: Large capacity, no evictions needed",
      "args": "( lambda ops=[('put',i,i*2) for i in range(10)] + [('get',5,)]: [\n  r for c in [LRUCache(100)]\n  for op in ops\n  for r in [c.get(op[1]) if op[0]=='get' else (c.put(op[1],op[2]) or None)]\n] )()",
      "expected": [null, null, null, null, null, null, null, null, null, null, 10],
      "ordered": true,
      "weight": 2
    }
  ],
  "hints": [
    "A plain dict doesn't give O(1) LRU eviction — you need to track order.",
    "Python's collections.OrderedDict move_to_end() + popitem(last=False) solves this elegantly.",
    "The O(1) interview-standard solution uses a doubly linked list + hash map.",
    "Watch out: put() on an existing key should refresh its recency, not add a duplicate."
  ],
  "referenceSolution": "from collections import OrderedDict\n\nclass LRUCache:\n    def __init__(self, capacity):\n        self.capacity = capacity\n        self.cache = OrderedDict()\n\n    def get(self, key):\n        if key not in self.cache:\n            return -1\n        self.cache.move_to_end(key)\n        return self.cache[key]\n\n    def put(self, key, value):\n        if key in self.cache:\n            self.cache.move_to_end(key)\n        self.cache[key] = value\n        if len(self.cache) > self.capacity:\n            self.cache.popitem(last=False)"
}
